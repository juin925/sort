## 정렬  
1. 버블정렬 : 서로 이웃한 데이터들을 비교하며 가장 큰 데이터를 가장 뒤로 보내며 정렬하는 방식.  
2. 선택정렬 : 정렬되지 않은 데이터들에 대해 가장 작은 데이터를 찾아 가장 앞의 데이터와 교환해나가는 방식.  
3. 삽입정렬 : 정렬되지 않은 임의의 데이터를 이미 정렬된 부분의 적절한 위치에 삽입해 가며 정렬하는 방식.  
4. 쉘 정렬  : 삽입 정렬의 성질을 이용하고 확장시켰으며 구간을 쪼개어 어느정도 정렬을 하고 마지막에 삽입 정렬을 시키는 방식.  
5. 힙 정렬 : 주어진 데이터들을 이진 트리로 구성하여 정렬하는 방식.  
6. 퀵 정렬 : 기준키를 기준으로 작거나 같은 값을 지닌 데이터는 앞으로, 큰 값을 지닌 데이터는 뒤로 가도록 하여 작은 값을 갖는 데이터와 큰 값을 갖는 데이터로 분리해가며 정렬하는 방식.  

**밑에는 걸린 시간이 나와있는데 2^4n 간격으로 계산했음. 2^20은 시간이 너무 많이 소요돼 계산하지 못했음.**

## 정렬이 안된 경우 걸린 시간
![](https://user-images.githubusercontent.com/101376856/166922508-3dbce84c-a4ba-4774-83a1-7c4769915b5b.PNG)  
![](https://user-images.githubusercontent.com/101376856/166922555-a20d13bc-15f2-47e4-8c75-d5987e010c5f.PNG)  

## 정렬이 된 경우 걸린 시간
![](https://user-images.githubusercontent.com/101376856/166922454-0cba0cf0-3de7-4b21-a83f-17a124c8a41d.PNG)  
![](https://user-images.githubusercontent.com/101376856/166922476-49a324dc-5ed7-4933-a3fb-b50f1f667a1f.PNG)  

## 역으로 정렬이 된 경우 걸린시간
![](https://user-images.githubusercontent.com/101376856/166922581-22bbdbcf-9d85-44c1-903c-fc079fe34cb5.PNG)  
![](https://user-images.githubusercontent.com/101376856/166923230-edd30579-d6de-487d-aa4e-897c41fb33ef.PNG) 

## 정렬의 시간복잡도  
![](https://user-images.githubusercontent.com/101376856/166922631-3555f378-1b19-48f0-b2f1-9dbd26af5814.PNG)  

## 하면서 느낀점  
2^20이 기다려도 퀵정렬과 힙정렬은 되는데 버블정렬과 같은 정렬들이 너무 오래 걸려서 컴퓨터의 처리속도가 한계가 있을 수 있구나를 몸으로 느낄 수 있었고 원래 쉘정렬이 다른 정렬들보다 걸린시간이 더 높게 나오면 안되는거같은데(추측이다) 더 높게 나오는거 보면 뭔가 코드에 문제가 있나싶다. 그리고 걸린시간을 계산하는 System.currentTimeMillis(); 함수를 인터넷 서치로 알게되었는데 꽤 유용하게 쓸 수 있을 것 같다.